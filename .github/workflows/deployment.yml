name: Deployment

on:
  push:
    branches: [ master ]
    tags: [ 'v*.*.*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for latest)'
        required: false
        type: string

permissions:
  contents: read
  packages: write
  id-token: write  # For OIDC authentication

concurrency:
  group: deploy-${{ github.event.inputs.environment || (github.ref == 'refs/heads/master' && 'staging') || 'production' }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  validate-deployment:
    name: Validate Deployment Prerequisites
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      version: ${{ steps.determine-version.outputs.version }}
      image-tag: ${{ steps.determine-version.outputs.image-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine target environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            ENVIRONMENT="staging"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENVIRONMENT="production"
          else
            echo "Invalid trigger for deployment"
            exit 1
          fi
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "Deploying to environment: $ENVIRONMENT"

      - name: Determine version to deploy
        id: determine-version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            IMAGE_TAG="$VERSION"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            IMAGE_TAG="$VERSION"
          else
            VERSION=$(git rev-parse --short HEAD)
            IMAGE_TAG="$VERSION"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Deploying version: $VERSION (image tag: $IMAGE_TAG)"

      - name: Validate image exists
        run: |
          echo "Validating that image exists: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.determine-version.outputs.image-tag }}"
          # This would typically check if the image exists in the registry
          # For now, we'll assume it exists if we reach this point

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: validate-deployment
    if: needs.validate-deployment.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (if using AWS)
        uses: aws-actions/configure-aws-credentials@v4
        if: false  # Enable if using AWS
        with:
          role-to-assume: ${{ secrets.AWS_STAGING_ROLE_ARN }}
          role-session-name: GitHubActions-Staging-Deploy
          aws-region: us-east-1

      - name: Deploy to staging
        run: |
          echo "üöÄ Deploying ${{ needs.validate-deployment.outputs.image-tag }} to staging environment"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-deployment.outputs.image-tag }}"
          
          # Example deployment commands (replace with your actual deployment method)
          # kubectl set image deployment/app app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-deployment.outputs.image-tag }}
          # kubectl rollout status deployment/app
          
          echo "‚úÖ Staging deployment completed"

      - name: Run smoke tests
        run: |
          echo "üß™ Running smoke tests against staging environment"
          
          # Wait for deployment to be ready
          sleep 30
          
          # Example smoke tests
          curl -f https://staging.example.com/actuator/health || exit 1
          curl -f https://staging.example.com/actuator/info || exit 1
          
          echo "‚úÖ Smoke tests passed"

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        if: success()
        with:
          status: success
          text: 'üöÄ Successfully deployed ${{ needs.validate-deployment.outputs.version }} to staging'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify deployment failure
        uses: 8398a7/action-slack@v3
        if: failure()
        with:
          status: failure
          text: '‚ùå Failed to deploy ${{ needs.validate-deployment.outputs.version }} to staging'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: validate-deployment
    if: needs.validate-deployment.outputs.environment == 'production'
    environment:
      name: production
      url: https://production.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (if using AWS)
        uses: aws-actions/configure-aws-credentials@v4
        if: false  # Enable if using AWS
        with:
          role-to-assume: ${{ secrets.AWS_PRODUCTION_ROLE_ARN }}
          role-session-name: GitHubActions-Production-Deploy
          aws-region: us-east-1

      - name: Pre-deployment checks
        run: |
          echo "üîç Running pre-deployment checks for production"
          
          # Check if staging deployment was successful
          # Check if all tests are passing
          # Check if security scans are clean
          
          echo "‚úÖ Pre-deployment checks passed"

      - name: Create deployment backup point
        run: |
          echo "üíæ Creating backup point before production deployment"
          
          # Example backup commands
          # kubectl get deployment app -o yaml > backup-deployment-$(date +%Y%m%d-%H%M%S).yaml
          
          echo "‚úÖ Backup point created"

      - name: Deploy to production (Blue-Green strategy)
        run: |
          echo "üöÄ Deploying ${{ needs.validate-deployment.outputs.image-tag }} to production environment"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-deployment.outputs.image-tag }}"
          
          # Blue-Green deployment example
          # 1. Deploy to green environment
          # kubectl set image deployment/app-green app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.validate-deployment.outputs.image-tag }}
          # kubectl rollout status deployment/app-green
          
          # 2. Run health checks on green
          # 3. Switch traffic from blue to green
          # 4. Monitor for issues
          # 5. Keep blue as rollback option
          
          echo "‚úÖ Production deployment completed"

      - name: Run comprehensive health checks
        run: |
          echo "üè• Running comprehensive health checks"
          
          # Wait for deployment stabilization
          sleep 60
          
          # Health checks
          curl -f https://production.example.com/actuator/health || exit 1
          curl -f https://production.example.com/actuator/info || exit 1
          
          # Performance checks
          curl -w "@curl-format.txt" -s -o /dev/null https://production.example.com/actuator/health
          
          echo "‚úÖ Health checks passed"

      - name: Monitor deployment metrics
        run: |
          echo "üìä Monitoring deployment metrics for 5 minutes"
          
          # Monitor error rates, response times, etc.
          # This would typically integrate with your monitoring system
          
          sleep 300  # Monitor for 5 minutes
          
          echo "‚úÖ Metrics look healthy"

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        if: success()
        with:
          status: success
          text: 'üéâ Successfully deployed ${{ needs.validate-deployment.outputs.version }} to production!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back production deployment due to failure"
          
          # Rollback commands
          # kubectl rollout undo deployment/app
          # kubectl rollout status deployment/app
          
          echo "‚úÖ Rollback completed"

      - name: Notify deployment failure
        uses: 8398a7/action-slack@v3
        if: failure()
        with:
          status: failure
          text: 'üö® Production deployment of ${{ needs.validate-deployment.outputs.version }} failed and was rolled back'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  cleanup:
    name: Post-Deployment Cleanup
    runs-on: ubuntu-latest
    needs: [ validate-deployment, deploy-staging, deploy-production ]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    steps:
      - name: Clean up old images
        run: |
          echo "üßπ Cleaning up old container images"
          # This would clean up old images from the registry
          echo "‚úÖ Cleanup completed"

      - name: Update deployment records
        run: |
          echo "üìù Updating deployment records"
          echo "Environment: ${{ needs.validate-deployment.outputs.environment }}"
          echo "Version: ${{ needs.validate-deployment.outputs.version }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          # This would typically update a deployment tracking system